package audio

import (
	"bytes"
	"encoding/binary"

	"github.com/gordonklaus/portaudio"
)

const (
	SampleRate = 16000
	Channels   = 1
	Seconds    = 5
)

// RecordAudio 采集指定秒数的音频，返回 wav 格式字节流
func RecordAudio() ([]byte, error) {
	portaudio.Initialize()
	defer portaudio.Terminate()

	buffer := make([]int16, SampleRate*Channels*Seconds)
	stream, err := portaudio.OpenDefaultStream(Channels, 0, float64(SampleRate), len(buffer), &buffer)
	if err != nil {
		return nil, err
	}
	defer stream.Close()

	err = stream.Start()
	if err != nil {
		return nil, err
	}
	defer stream.Stop()

	err = stream.Read()
	if err != nil {
		return nil, err
	}

	// 写入 wav 头和数据
	buf := new(bytes.Buffer)
	writeWavHeader(buf, uint32(len(buffer)*2))
	binary.Write(buf, binary.LittleEndian, buffer)
	return buf.Bytes(), nil
}

// 写入最简 wav 头
func writeWavHeader(buf *bytes.Buffer, dataLen uint32) {
	buf.WriteString("RIFF")
	binary.Write(buf, binary.LittleEndian, uint32(36+dataLen))
	buf.WriteString("WAVEfmt ")
	binary.Write(buf, binary.LittleEndian, uint32(16))
	binary.Write(buf, binary.LittleEndian, uint16(1))
	binary.Write(buf, binary.LittleEndian, uint16(Channels))
	binary.Write(buf, binary.LittleEndian, uint32(SampleRate))
	binary.Write(buf, binary.LittleEndian, uint32(SampleRate*Channels*2))
	binary.Write(buf, binary.LittleEndian, uint16(Channels*2))
	binary.Write(buf, binary.LittleEndian, uint16(16))
	buf.WriteString("data")
	binary.Write(buf, binary.LittleEndian, dataLen)
}
